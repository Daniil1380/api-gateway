
Конечно, вот пример README-файла для вашего проекта, включающий объяснение в формате ADR (Architecture Decision Record) о необходимости использования API Gateway.

---

# API Gateway Service

Этот проект представляет собой API Gateway, построенный с использованием Spring Cloud Gateway. Он служит единой точкой входа для всех клиентских запросов в нашей микросервисной архитектуре.

## Функциональные возможности

*   **Маршрутизация запросов**: Направляет входящие запросы к соответствующим микросервисам с помощью Service Discovery (например, Eureka, Consul).
*   **Централизованное логирование**: Логирует все входящие запросы и исходящие ответы.
*   **Трассировка запросов**: Добавляет уникальный `X-Trace-Id` к каждому запросу для упрощения отслеживания и отладки в распределенной системе.
*   **Обработка JWT**: Пропускает заголовок `Authorization` к нижестоящим сервисам для их последующей валидации.
*   **Безопасность**: Базовая конфигурация безопасности для защиты самого шлюза.

## Технологический стек

*   Java 17+
*   Spring Boot 3.x
*   Spring Cloud Gateway
*   Spring Security
*   Lombok
*   Service Discovery (Eureka/Consul и т.д.)

## Запуск приложения

1.  Убедитесь, что у вас установлен Java 17+ и Maven.
2.  Запустите сервис Service Discovery (например, Eureka Server).
3.  Запустите это приложение:
    ```bash
    mvn spring-boot:run
    ```
    или через вашу IDE.

## Конфигурация

Правила маршрутизации и другие настройки определяются в файле `application.yml` (или `application.properties`). Пример конфигурации для маршрутизации:

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://user-service # lb:// означает балансировку нагрузки через Service Discovery
          predicates:
            - Path=/api/users/**
        - id: order-service
          uri: lb://order-service
          predicates:
            - Path=/api/orders/**
```

---

## ADR-1: Почему был внедрен API Gateway?

**Статус**: Принято

**Контекст**:

В нашей архитектуре используется несколько независимых микросервисов (например, сервис пользователей, сервис заказов, сервис товаров). Без центральной точки входа возникли бы следующие проблемы:

1.  **Сложность для клиента**: Клиентскому приложению (веб или мобильному) необходимо было бы знать адреса (IP, порты) каждого микросервиса и самостоятельно управлять вызовами. Это усложняет код клиента и делает его хрупким.
2.  **Дублирование сквозной логики**: Такие задачи, как аутентификация, авторизация, логирование, ограничение частоты запросов (rate limiting) и трассировка, пришлось бы реализовывать в каждом сервисе. Это ведет к дублированию кода, сложностям в поддержке и несоответствиям в реализации.
3.  **Проблемы безопасности**: Каждый микросервис должен был бы быть открыт в интернет, что увеличивает поверхность атаки. Управление CORS, SSL/TLS и другими аспектами безопасности стало бы более сложным.
4.  **Сложность рефакторинга**: Любое изменение в структуре микросервисов (например, слияние или разделение сервиса) потребовало бы обновления всех клиентских приложений.

**Решение**:

Мы решили внедрить **API Gateway** как единый входной узел для всех внешних запросов. Spring Cloud Gateway был выбран как идеальный инструмент для этой задачи в экосистеме Spring.

API Gateway выполняет следующие роли:
*   **Единая точка входа**: Клиенты взаимодействуют только с адресом шлюза.
*   **Прокси-сервер**: Шлюз перенаправляет запросы соответствующим микросервисам.
*   **Централизованный обработчик сквозных задач**: Аутентификация, логирование, трассировка и другие аспекты обрабатываются в одном месте.

**Последствия**:

*   **Положительные**:
    *   **Упрощение клиентского кода**: Клиентам нужно знать только один URL.
    *   **Централизованное управление**: Логика безопасности, логирования и трассировки находится в одном компоненте, что упрощает ее поддержку и обновление.
    *   **Улучшенная безопасность**: Внутренние сервисы скрыты от внешнего мира, доступ к ним идет только через шлюз.
    *   **Улучшенная наблюдаемость**: Благодаря `X-Trace-Id` (реализованному в `TraceAndJwtFilter`), легко отследить путь запроса через всю систему.
    *   **Гибкость**: Можно легко менять маршрутизацию, добавлять новые версии API или выполнять A/B-тестирование, не затрагивая клиентские приложения.

*   **Отрицательные**:
    *   **Единая точка отказа (Single Point of Failure)**: Шлюз становится критически важным компонентом. Его недоступность сделает недоступной всю систему. Требуется высокая доступность (например, путем запуска нескольких экземпляров шлюза).
    *   **Увеличение сложности**: В архитектуру добавляется еще один компонент, который нужно разрабатывать, развертывать и поддерживать.
    *   **Возможное узкое место**: Шлюз может стать производительным узким местом, если он не спроектирован и не масштабирован должным образом.

---

## Ключевые компоненты

### `TraceAndJwtFilter.java`

Этот глобальный фильтр (`GlobalFilter`) является ядром сквозной логики.
*   **Трассировка**: Он генерирует уникальный `traceId` для каждого запроса, добавляет его в заголовок ответа `X-Trace-Id` и логирует все события с этим ID.
*   **Логирование**: Фиксирует информацию о входящих запросах (метод, URI) и исходящих ответах (статус).
*   **Обработка JWT**: Он извлекает заголовок `Authorization` из запроса и передает его дальше к микросервису. Это позволяет самим микросервисам выполнять валидацию токена, разгружая шлюз от бизнес-логики авторизации.

### `SecurityConfig.java`

Конфигурация безопасности Spring Security для самого шлюза.
*   В текущем виде она отключает CSRF и разрешает все запросы (`permitAll()`). Это распространенный подход, когда шлюз не выполняет аутентификацию сам, а лишь прозрачно передает токены downstream-сервисам, которые уже отвечают за проверку и авторизацию.
*   Это делает шлюз "прозрачным" с точки зрения безопасности, но при этом защищенным от атак типа CSRF.

### `ApiGatewayApplication.java`

Главный класс приложения.
*   Аннотация `@EnableDiscoveryClient` является ключевой. Она включает функционал Service Discovery, позволяя шлюзу автоматически находить и регистрировать микросервисы в инфраструктуре (например, в Eureka). Это основа для динамической маршрутизации запросов.